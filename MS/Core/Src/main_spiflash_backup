/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file           : main_spiflash_test.c
  * @brief          : Test completo para SPI Flash con debug multi-modal
  ******************************************************************************
  */
/* USER CODE END Header */

/* Includes ------------------------------------------------------------------*/
#include "main.h"
#include "dma.h"
#include "fatfs.h"
#include "i2c.h"
#include "spi.h"
#include "tim.h"
#include "gpio.h"
#include "SPIFlash.h"
#include "WS2812B.h"
#include "Buzzer.h"
#include "SDLogger.h"
#include <stdlib.h>

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */

/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */

// Estructura de datos de prueba
typedef struct {
    uint32_t timestamp;
    float temperature;
    float pressure;
    double latitude;
    double longitude;
    uint16_t counter;
    char message[32];
} TestData_t;

/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */

#define TEST_START_ADDRESS      0x000000
#define TEST_STRING_ADDRESS     0x001000
#define TEST_STRUCT_ADDRESS     0x002000
#define TEST_SECTOR_ADDRESS     0x010000

/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/

/* USER CODE BEGIN PV */
SPIFlash_t spi_flash;
WS2812B_t led_status;
Buzzer_t buzzer;
SDLogger_t sd_logger;
/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
/* USER CODE BEGIN PFP */

/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */

// Test de información del chip
void SPIFlash_TestChipInfo(void) {
    SDLogger_WriteText(&sd_logger, "=== TEST CHIP INFO ===\n");

    char info_buffer[256];
    SPIFlash_GetChipInfoString(&spi_flash, info_buffer, sizeof(info_buffer));

    char log_msg[256];
    sprintf(log_msg, "Chip Info: %s\n", info_buffer);
    SDLogger_WriteText(&sd_logger, log_msg);

    sprintf(log_msg, "Total Size: %lu bytes (%lu MB)\n",
            SPIFlash_GetTotalSize(&spi_flash),
            SPIFlash_GetTotalSize(&spi_flash) / (1024*1024));
    SDLogger_WriteText(&sd_logger, log_msg);

    // Verificar si es W25Q128JVS específicamente
    if (SPIFlash_IsW25Q128(&spi_flash)) {
        SDLogger_WriteText(&sd_logger, "Chip confirmado: W25Q128JVS (16MB)\n");

        // Mostrar mapa de memoria detallado
        char memory_map[512];
        SPIFlash_GetMemoryMap(&spi_flash, memory_map, sizeof(memory_map));
        SDLogger_WriteText(&sd_logger, memory_map);
        SDLogger_WriteText(&sd_logger, "\n");

        sprintf(log_msg, "Sectores disponibles: %lu\n", SPIFlash_GetSectorCount(&spi_flash));
        SDLogger_WriteText(&sd_logger, log_msg);

        sprintf(log_msg, "Paginas disponibles: %lu\n", SPIFlash_GetPageCount(&spi_flash));
        SDLogger_WriteText(&sd_logger, log_msg);

        // LED verde - chip W25Q128JVS confirmado
        WS2812B_SetColor(&led_status, WS2812B_COLOR_GREEN);
        BUZZER_SUCCESS(&buzzer);
    } else {
        SDLogger_WriteText(&sd_logger, "ADVERTENCIA: Chip no es W25Q128JVS\n");
        WS2812B_SetColor(&led_status, WS2812B_COLOR_YELLOW);
        BUZZER_WARNING(&buzzer);
    }

    SDLogger_WriteText(&sd_logger, "Chip identificado correctamente\n\n");
    SDLogger_Flush(&sd_logger);
}

// Test de lectura/escritura básica
void SPIFlash_TestBasicReadWrite(void) {
    SDLogger_WriteText(&sd_logger, "=== TEST LECTURA/ESCRITURA BASICA ===\n");

    WS2812B_SetColor(&led_status, WS2812B_COLOR_BLUE);
    Buzzer_BeepType(&buzzer, BUZZER_BEEP_MEDIUM);

    // Test datos de prueba
    uint8_t write_data[] = {0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF};
    uint8_t read_data[8] = {0};

    // Escribir datos
    SDLogger_WriteText(&sd_logger, "Escribiendo datos de prueba...\n");
    if (SPIFlash_WriteData(&spi_flash, TEST_START_ADDRESS, write_data, sizeof(write_data))) {
        SDLogger_WriteText(&sd_logger, "Escritura: SUCCESS\n");
    } else {
        SDLogger_WriteText(&sd_logger, "Escritura: ERROR\n");
        BUZZER_ERROR(&buzzer);
        return;
    }

    // Leer datos
    SDLogger_WriteText(&sd_logger, "Leyendo datos...\n");
    if (SPIFlash_ReadData(&spi_flash, TEST_START_ADDRESS, read_data, sizeof(read_data))) {
        SDLogger_WriteText(&sd_logger, "Lectura: SUCCESS\n");

        // Verificar datos
        bool data_ok = true;
        for (int i = 0; i < 8; i++) {
            if (write_data[i] != read_data[i]) {
                data_ok = false;
                break;
            }
        }

        if (data_ok) {
            SDLogger_WriteText(&sd_logger, "Verificacion: DATOS CORRECTOS\n");
            WS2812B_SetColor(&led_status, WS2812B_COLOR_GREEN);
            BUZZER_SUCCESS(&buzzer);
        } else {
            SDLogger_WriteText(&sd_logger, "Verificacion: DATOS INCORRECTOS\n");
            WS2812B_SetColor(&led_status, WS2812B_COLOR_RED);
            BUZZER_ERROR(&buzzer);
        }

        // Log datos leídos
        char log_msg[256];
        sprintf(log_msg, "Datos leidos: ");
        for (int i = 0; i < 8; i++) {
            sprintf(log_msg + strlen(log_msg), "0x%02X ", read_data[i]);
        }
        strcat(log_msg, "\n");
        SDLogger_WriteText(&sd_logger, log_msg);

    } else {
        SDLogger_WriteText(&sd_logger, "Lectura: ERROR\n");
        BUZZER_ERROR(&buzzer);
    }

    SDLogger_WriteText(&sd_logger, "Test basico completado\n\n");
    SDLogger_Flush(&sd_logger);
}

// Test de strings
void SPIFlash_TestStrings(void) {
    SDLogger_WriteText(&sd_logger, "=== TEST STRINGS ===\n");

    WS2812B_SetColor(&led_status, WS2812B_COLOR_YELLOW);
    Buzzer_BeepType(&buzzer, BUZZER_BEEP_MEDIUM);

    const char *test_string = "Hello SPI Flash World! Prueba de texto.";
    char read_string[64] = {0};

    // Escribir string
    SDLogger_WriteText(&sd_logger, "Escribiendo string de prueba...\n");
    if (SPIFlash_WriteString(&spi_flash, TEST_STRING_ADDRESS, test_string)) {
        SDLogger_WriteText(&sd_logger, "Escritura string: SUCCESS\n");

        // Leer string
        if (SPIFlash_ReadString(&spi_flash, TEST_STRING_ADDRESS, read_string, sizeof(read_string))) {
            SDLogger_WriteText(&sd_logger, "Lectura string: SUCCESS\n");

            // Verificar
            if (strcmp(test_string, read_string) == 0) {
                SDLogger_WriteText(&sd_logger, "Verificacion string: CORRECTA\n");
                WS2812B_SetColor(&led_status, WS2812B_COLOR_GREEN);
                BUZZER_SUCCESS(&buzzer);
            } else {
                SDLogger_WriteText(&sd_logger, "Verificacion string: INCORRECTA\n");
                WS2812B_SetColor(&led_status, WS2812B_COLOR_RED);
                BUZZER_ERROR(&buzzer);
            }

            char log_msg[128];
            sprintf(log_msg, "String leido: '%s'\n", read_string);
            SDLogger_WriteText(&sd_logger, log_msg);

        } else {
            SDLogger_WriteText(&sd_logger, "Lectura string: ERROR\n");
            BUZZER_ERROR(&buzzer);
        }
    } else {
        SDLogger_WriteText(&sd_logger, "Escritura string: ERROR\n");
        BUZZER_ERROR(&buzzer);
    }

    SDLogger_WriteText(&sd_logger, "Test strings completado\n\n");
    SDLogger_Flush(&sd_logger);
}

// Test de estructuras
void SPIFlash_TestStructures(void) {
    SDLogger_WriteText(&sd_logger, "=== TEST ESTRUCTURAS ===\n");

    WS2812B_SetColor(&led_status, WS2812B_COLOR_CYAN);
    Buzzer_BeepType(&buzzer, BUZZER_BEEP_MEDIUM);

    // Primero borrar el sector para test limpio
    SDLogger_WriteText(&sd_logger, "Borrando sector de estructuras...\n");
    if (!SPIFlash_EraseSector(&spi_flash, TEST_STRUCT_ADDRESS)) {
        SDLogger_WriteText(&sd_logger, "Error borrando sector\n");
        BUZZER_ERROR(&buzzer);
        return;
    }

    // Datos de prueba con timestamp fijo para verificación
    TestData_t write_struct = {
        .timestamp = 0x12345678,  // Timestamp fijo para verificación consistente
        .temperature = 23.5f,
        .pressure = 1013.25f,
        .latitude = 40.416775,
        .longitude = -3.703790,
        .counter = 12345,
    };
    strcpy(write_struct.message, "Test Structure Data");

    TestData_t read_struct = {0};

    // Log datos que vamos a escribir
    char log_msg[256];
    sprintf(log_msg, "Escribiendo: Timestamp=0x%08lX, Counter=%d\n",
            write_struct.timestamp, write_struct.counter);
    SDLogger_WriteText(&sd_logger, log_msg);

    // Escribir estructura
    SDLogger_WriteText(&sd_logger, "Escribiendo estructura de prueba...\n");
    if (SPIFlash_WriteStruct(&spi_flash, TEST_STRUCT_ADDRESS, &write_struct, sizeof(write_struct))) {
        SDLogger_WriteText(&sd_logger, "Escritura estructura: SUCCESS\n");

        // Pequeña espera para asegurar escritura
        HAL_Delay(10);

        // Leer estructura
        if (SPIFlash_ReadStruct(&spi_flash, TEST_STRUCT_ADDRESS, &read_struct, sizeof(read_struct))) {
            SDLogger_WriteText(&sd_logger, "Lectura estructura: SUCCESS\n");

            // Log datos leídos
            sprintf(log_msg, "Leido: Timestamp=0x%08lX, Counter=%d\n",
                    read_struct.timestamp, read_struct.counter);
            SDLogger_WriteText(&sd_logger, log_msg);

            // Verificar todos los campos importantes
            bool timestamp_ok = (write_struct.timestamp == read_struct.timestamp);
            bool temp_ok = (write_struct.temperature == read_struct.temperature);
            bool counter_ok = (write_struct.counter == read_struct.counter);
            bool message_ok = (strcmp(write_struct.message, read_struct.message) == 0);

            sprintf(log_msg, "Verificacion individual:\n");
            SDLogger_WriteText(&sd_logger, log_msg);
            sprintf(log_msg, "  Timestamp: %s\n", timestamp_ok ? "OK" : "FAIL");
            SDLogger_WriteText(&sd_logger, log_msg);
            sprintf(log_msg, "  Temperature: %s\n", temp_ok ? "OK" : "FAIL");
            SDLogger_WriteText(&sd_logger, log_msg);
            sprintf(log_msg, "  Counter: %s\n", counter_ok ? "OK" : "FAIL");
            SDLogger_WriteText(&sd_logger, log_msg);
            sprintf(log_msg, "  Message: %s\n", message_ok ? "OK" : "FAIL");
            SDLogger_WriteText(&sd_logger, log_msg);

            bool struct_ok = timestamp_ok && temp_ok && counter_ok && message_ok;

            if (struct_ok) {
                SDLogger_WriteText(&sd_logger, "Verificacion estructura: CORRECTA\n");
                WS2812B_SetColor(&led_status, WS2812B_COLOR_GREEN);
                BUZZER_SUCCESS(&buzzer);
            } else {
                SDLogger_WriteText(&sd_logger, "Verificacion estructura: INCORRECTA\n");
                WS2812B_SetColor(&led_status, WS2812B_COLOR_RED);
                BUZZER_ERROR(&buzzer);
            }

            // Log datos finales
            int32_t temp_int = (int32_t)(read_struct.temperature * 10);
            sprintf(log_msg, "Datos finales - Timestamp: 0x%08lX, Temp: %ld.%ld, Counter: %d\n",
                    read_struct.timestamp, temp_int/10, abs(temp_int%10), read_struct.counter);
            SDLogger_WriteText(&sd_logger, log_msg);

            sprintf(log_msg, "Mensaje: '%s'\n", read_struct.message);
            SDLogger_WriteText(&sd_logger, log_msg);

        } else {
            SDLogger_WriteText(&sd_logger, "Lectura estructura: ERROR\n");
            BUZZER_ERROR(&buzzer);
        }
    } else {
        SDLogger_WriteText(&sd_logger, "Escritura estructura: ERROR\n");
        BUZZER_ERROR(&buzzer);
    }

    SDLogger_WriteText(&sd_logger, "Test estructuras completado\n\n");
    SDLogger_Flush(&sd_logger);
}

// Test de borrado de sector
void SPIFlash_TestErase(void) {
    SDLogger_WriteText(&sd_logger, "=== TEST BORRADO SECTOR ===\n");

    WS2812B_SetColor(&led_status, WS2812B_COLOR_MAGENTA);
    Buzzer_BeepType(&buzzer, BUZZER_BEEP_LONG);

    // Escribir datos en el sector de prueba
    uint8_t test_pattern[256];
    for (int i = 0; i < 256; i++) {
        test_pattern[i] = i & 0xFF;
    }

    SDLogger_WriteText(&sd_logger, "Escribiendo patron de prueba...\n");
    if (SPIFlash_WriteData(&spi_flash, TEST_SECTOR_ADDRESS, test_pattern, sizeof(test_pattern))) {
        SDLogger_WriteText(&sd_logger, "Escritura patron: SUCCESS\n");

        // Borrar sector
        SDLogger_WriteText(&sd_logger, "Borrando sector...\n");
        if (SPIFlash_EraseSector(&spi_flash, TEST_SECTOR_ADDRESS)) {
            SDLogger_WriteText(&sd_logger, "Borrado sector: SUCCESS\n");

            // Verificar que está borrado (debe leer 0xFF)
            uint8_t read_buffer[256];
            if (SPIFlash_ReadData(&spi_flash, TEST_SECTOR_ADDRESS, read_buffer, sizeof(read_buffer))) {
                bool erased_ok = true;
                for (int i = 0; i < 256; i++) {
                    if (read_buffer[i] != 0xFF) {
                        erased_ok = false;
                        break;
                    }
                }

                if (erased_ok) {
                    SDLogger_WriteText(&sd_logger, "Verificacion borrado: CORRECTA\n");
                    WS2812B_SetColor(&led_status, WS2812B_COLOR_GREEN);
                    BUZZER_SUCCESS(&buzzer);
                } else {
                    SDLogger_WriteText(&sd_logger, "Verificacion borrado: INCORRECTA\n");
                    WS2812B_SetColor(&led_status, WS2812B_COLOR_RED);
                    BUZZER_ERROR(&buzzer);
                }
            } else {
                SDLogger_WriteText(&sd_logger, "Lectura verificacion: ERROR\n");
                BUZZER_ERROR(&buzzer);
            }
        } else {
            SDLogger_WriteText(&sd_logger, "Borrado sector: ERROR\n");
            BUZZER_ERROR(&buzzer);
        }
    } else {
        SDLogger_WriteText(&sd_logger, "Escritura patron: ERROR\n");
        BUZZER_ERROR(&buzzer);
    }

    SDLogger_WriteText(&sd_logger, "Test borrado completado\n\n");
    SDLogger_Flush(&sd_logger);
}

// Test de diagnósticos
void SPIFlash_TestDiagnostics(void) {
    SDLogger_WriteText(&sd_logger, "=== DIAGNOSTICOS SPI FLASH ===\n");

    char log_msg[128];

    // Status register
    uint8_t status = SPIFlash_ReadStatus(&spi_flash);
    sprintf(log_msg, "Status Register: 0x%02X\n", status);
    SDLogger_WriteText(&sd_logger, log_msg);

    sprintf(log_msg, "  BUSY: %s\n", (status & 0x01) ? "YES" : "NO");
    SDLogger_WriteText(&sd_logger, log_msg);

    sprintf(log_msg, "  WEL: %s\n", (status & 0x02) ? "YES" : "NO");
    SDLogger_WriteText(&sd_logger, log_msg);

    // Estados de pines de control
    sprintf(log_msg, "Write Protection: %s\n",
            spi_flash.write_protection_enabled ? "ENABLED" : "DISABLED");
    SDLogger_WriteText(&sd_logger, log_msg);

    sprintf(log_msg, "Flash Ready: %s\n",
            SPIFlash_IsReady(&spi_flash) ? "YES" : "NO");
    SDLogger_WriteText(&sd_logger, log_msg);

    sprintf(log_msg, "Initialized: %s\n",
            spi_flash.is_initialized ? "YES" : "NO");
    SDLogger_WriteText(&sd_logger, log_msg);

    SDLogger_WriteText(&sd_logger, "Diagnosticos completados\n\n");
    SDLogger_Flush(&sd_logger);
}

/* USER CODE END 0 */

/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
  /* USER CODE BEGIN 1 */

  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();

  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();

  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
  MX_DMA_Init();
  MX_SPI1_Init();
  MX_FATFS_Init();
  MX_I2C3_Init();
  MX_TIM1_Init();
  /* USER CODE BEGIN 2 */

  // Inicializar componentes de debug
  Buzzer_Init(&buzzer);
  WS2812B_Init(&led_status, &htim1, TIM_CHANNEL_2);

  // Beep de inicio del sistema
  BUZZER_INIT_OK(&buzzer);
  WS2812B_SetColor(&led_status, WS2812B_COLOR_WHITE);
  HAL_Delay(1000);

  // Inicializar SD para logging
  if (SDLogger_Init(&sd_logger)) {
      SDLogger_CreateDebugFile(&sd_logger);
      SDLogger_WriteText(&sd_logger, "=== SPI FLASH TEST DEBUG START ===\n");
      WS2812B_SetColor(&led_status, WS2812B_COLOR_GREEN);
      BUZZER_SUCCESS(&buzzer);
  } else {
      WS2812B_SetColor(&led_status, WS2812B_COLOR_RED);
      BUZZER_ERROR(&buzzer);
      while(1); // Error crítico
  }

  // Inicializar SPI Flash
  SDLogger_WriteText(&sd_logger, "Inicializando SPI Flash...\n");
  if (SPIFlash_Init(&spi_flash, &hspi1)) {
      SDLogger_WriteText(&sd_logger, "SPIFlash_Init: SUCCESS\n");
      WS2812B_SetColor(&led_status, WS2812B_COLOR_GREEN);
      BUZZER_SUCCESS(&buzzer);
  } else {
      SDLogger_WriteText(&sd_logger, "SPIFlash_Init: ERROR\n");
      WS2812B_SetColor(&led_status, WS2812B_COLOR_RED);
      BUZZER_ERROR(&buzzer);
      while(1); // Error crítico
  }

  SDLogger_Flush(&sd_logger);
  HAL_Delay(2000);
  WS2812B_TurnOff(&led_status);

  /* USER CODE END 2 */

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
  {
      // Test información del chip
      SPIFlash_TestChipInfo();
      HAL_Delay(2000);

      // Diagnósticos
      SPIFlash_TestDiagnostics();
      HAL_Delay(2000);

      // Test básico lectura/escritura
      SPIFlash_TestBasicReadWrite();
      HAL_Delay(3000);

      // Test de strings
      SPIFlash_TestStrings();
      HAL_Delay(3000);

      // Test de estructuras
      SPIFlash_TestStructures();
      HAL_Delay(3000);

      // Test de borrado
      SPIFlash_TestErase();
      HAL_Delay(3000);

      // Indicar fin del ciclo
      WS2812B_SetColor(&led_status, WS2812B_COLOR_WHITE);
      Buzzer_Pattern(&buzzer, BUZZER_PATTERN_STARTUP);
      WS2812B_TurnOff(&led_status);

      SDLogger_WriteText(&sd_logger, "=== CICLO DE TEST SPI FLASH COMPLETADO ===\n\n");
      SDLogger_Flush(&sd_logger);

      HAL_Delay(5000); // Esperar antes del siguiente ciclo

    /* USER CODE END WHILE */

    /* USER CODE BEGIN 3 */
  }
  /* USER CODE END 3 */
}

/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

  /** Configure the main internal regulator output voltage
  */
  __HAL_RCC_PWR_CLK_ENABLE();
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);

  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
  RCC_OscInitStruct.PLL.PLLM = 4;
  RCC_OscInitStruct.PLL.PLLN = 80;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
  RCC_OscInitStruct.PLL.PLLQ = 4;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
  {
    Error_Handler();
  }

  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
  {
    Error_Handler();
  }
}

/* USER CODE BEGIN 4 */

/* USER CODE END 4 */

/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
  {
  }
  /* USER CODE END Error_Handler_Debug */
}

#ifdef  USE_FULL_ASSERT
/**
  * @brief  Reports the name and source line number where the assert_param error has occurred.
  * @param  file: pointer to the source file name
  * @param  line: assert_param error line source number
  * @retval None
  */
void assert_failed(uint8_t *file, uint32_t line)
{
  /* USER CODE BEGIN 6 */
  /* User can add his own implementation to report the file name and line number,
     ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
  /* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */
